use std::{fs, fs::File};
use std::collections::HashMap;
use std::io::prelude::*;
use mongodb::sync::Client;
use rocket::State;
use rocket::fairing::Result;
use crate::MyManagedState;
use crate::instance::*;
use crate::util;
pub struct InstanceManager{
    instance_collection : HashMap<String, ServerInstance>,
    avail_ports : Vec<u16>,
    path : String, // must end with /
    mongodb : Client,
}


// TODO: DB IO
// TODO : should prob change parameter String to &str
impl InstanceManager {
    pub fn new(path : String, mongodb : Client) -> InstanceManager {
        InstanceManager{
            instance_collection : HashMap::new(),
            path,
            mongodb,
            avail_ports : vec![]
        }
    }
    // TODO: server.properties 
    pub async fn create_instance(&mut self, name : String, version : String, config : Option<InstanceConfig>, state: &State<MyManagedState>) -> Result<String, String> {
        if self.check_if_name_exists(&name) {
            return Err(format!("{} already exists as an instance", name));
        }
        let path_to_instance = format!("{}{}/", self.path, name);
        let path_to_eula = format!("{}eula.txt", path_to_instance);
        fs::create_dir(path_to_instance.as_str()).map_err(|e| e.to_string())?;
        let url = util::get_vanilla_version_url(version)?;
        let instance = ServerInstance::new(config, path_to_instance.clone(), name.clone());
        let uuid = instance.uuid.clone();
        util::download_file(url.as_str(), format!("{}server.jar", &path_to_instance).as_str(), state, instance.uuid.as_str()).await?; // TODO: get rid of await
        let mut eula_file = File::create(path_to_eula.as_str()).map_err(|e| e.to_string())?;
        eula_file.write_all(b"#generated by Lodestone\neula=true\n").map_err(|e| e.to_string())?;
        self.instance_collection.insert(instance.uuid.clone(), instance);
        Ok(uuid)
    }

    pub fn delete_instance(&mut self, uuid : String) -> Result<(), String> {
        match self.instance_collection.remove(&uuid) {
            None => Err("instance not found".to_string()),
            Some(instance) => {
                fs::remove_dir_all(format!("{}{}", self.path, instance.name)).map_err(|e| e.to_string())?;
                Ok(())
            }
        }
    }

    pub fn clone_instance(&mut self, uuid : String) -> Result<(), String> {
        for pair in &self.instance_collection {
            if pair.0 == &uuid {
                if self.check_if_name_exists(&format!("{}_copy", &pair.1.name)) {
                    return Err(format!("{}_copy already exists as an instance", &pair.1.name));
                }
            }
        };
        Ok(())
    }

    pub fn send_command(&self, uuid : String, command : String) -> Result<(), String> {
        let instance = self.instance_collection.get(&uuid).ok_or("cannot send command to instance as it does not exist".to_string())?;
        instance.stdin.clone().unwrap().send(format!("{}\n", command)).map_err(|e| "failed to send command to instance".to_string())?;
        Ok(())
    }

    pub fn start_instance(&mut self, uuid : String) -> Result<(), String> {
        let instance = self.instance_collection.get_mut(&uuid).ok_or("instance cannot be started as it does not exist".to_string())?;
        instance.start(self.mongodb.clone())
    }

    pub fn stop_instance(&mut self, uuid : String) -> Result<(), String> {
        let instance = self.instance_collection.get_mut(&uuid).ok_or("instance cannot be stopped as it does not exist".to_string())?;
        instance.stop()
    }

    fn check_if_name_exists(&self, name : &String) -> bool {
        let mut ret = false;
        for pair in &self.instance_collection {
            if &pair.1.name == name {
                ret = true;
                break; 
            }
        }
        ret
    }



}
